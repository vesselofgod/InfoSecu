PART A: Signing and Verifying Code Sections

우선 sign을 하는 것과 verify를 하는 것은 openssl의 sign과 verify를 지원하기에 이를 사용해서 기본적으로 진행하였고, public key와 private key의 경우에는 명세에서 주어진 명령어를 사용해서 생성할 수 있었다. 이러한 key를 통해서 전자서명을 진행하는 과정에서 onenssl의 Rsa, Pkey를 사용하였고, sign을 할 private key를 sha 256으로 해쉬를 진행 (signer 공식 문서 참조 : [https://docs.rs/openssl/latest/openssl/sign/index.html](https://docs.rs/openssl/latest/openssl/sign/index.html))하였다. 그 다음에 ELF file에서  executable section을 이용해서 sign을 해야 하는데, 이 section의 binary data를 얻어내기 위해  rust의 elf library를 사용하여 각각의 section의 flag를 확인하는 과정(SHF_EXECINSTR를 확인해야 하는데 이 경우 6이 mapping되어 있었다.) 그래서 flag==6인 section을 signer에 update를 시킨 다음에 sign을 저장하는 파일(sig_file)을 생성하고 난 후, 이 파일과 objcopy 명령어를 사용해서 .signature section을 생성할 수 있었다.

$ objcopy --add-section .signatureee=./sig_file --set-section-flags .signature=noload,readonly licensechk-signed licensechk-signed-signed
(이 명령을 rust 프로그램 내부에서 돌림.)

그리고 Verify의 경우에는 .signature라는 이름을 가진 section이 있는지를 검사하고 만약 없으면 NOT_SIGNED를 출력하고 main 함수를 return하면서 프로그램을 종료시켰다. .signature section이 존재하는 경우에는 section의 offset과 size를 이용해서 elf file vector를 slicing해서 해당 서명에 대한 정보를 추출한 다음에 openssl의 Verifier를 사용하여 서명을 추출하였다. 추출 과정은 역시 signer와 상당히 유사하게 executable section을 update하고 그렇게 해서 얻어낸 서명이 원본에서 추출한 서명과 동일한지를 확인하고, 만약 동일하다면 OK를, 동일하지 않다면 NOT_OK를 출력하였다.

PART B:Bypassing Code Integrity
우선 주어진 licensechk-signed을 분석하기 위해서 readelf --sections licensechk-signed를 이용해서 section들이 어떻게 들어가있는지 확인한 다음, objdump -d licensechk-signed를 사용해서 명세에 주어진 코드에 구성된 함수들을 상세하게 살펴볼 수 있었다.이 프로그램에서는 do_license_check_v2라는 함수를 이용해서 license check를 진행하는데, do_license_check_v2 함수의 내용을 변경하면 sign과정에서 section을 변경한 것을 알 수 있으므로 do_license_check_v2 함수의 포인터값을 원래 함수 대신 do_nothing 함수의 포인터값으로 변경하면 된다고 생각하였다. 이 때 아까 분석한 결과로는 (4011cf) (cf11 40 773,891)이 일단 do_license_check_v2의 포인터이고, 4012d1(d112 40, line 874)이 do nothing의 pointer이다. line 800번쪽은 함수를 선언하기 위한 정보라고 판단하였기에 line 773을 cf11 40에서 d112 40로 변경하였더니 어떠한 license number가 오더라도 valid로 check하는 것 (return 0이기에 무조건 valid임.)으로 파일을 변경하였다. 그렇지만 주어진 licensechk-signed를 서명한 key들이 주어지지 않기에 어떤 경우에도 NOT_OK를 하는 것이 문제라고 생각하여 objcopy --remove-section .signature licensechk-signed을 통해서 기존 licensechk-signed의 서명을 제거한 다음 직접 생성한 private key로 서명한 다음, 그 쌍의 public key로 서명을 확인해서 signature check까지 통과하는 것을 확인할 수 있었다.